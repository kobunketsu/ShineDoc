<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shine: C API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Shine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">C API<div class="ingroups"><a class="el" href="group__objdetect.html">Object Detection</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_feature.html">CvHaarFeature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_classifier.html">CvHaarClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_stage_classifier.html">CvHaarStageClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_avg_comp.html">CvAvgComp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacd8ee8b3cdc5253a300a3b786ff762b0" id="r_gacd8ee8b3cdc5253a300a3b786ff762b0"><td class="memItemLeft" align="right" valign="top"><a id="gacd8ee8b3cdc5253a300a3b786ff762b0" name="gacd8ee8b3cdc5253a300a3b786ff762b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_MAGIC_VAL</b>&#160;&#160;&#160;0x42500000</td></tr>
<tr class="separator:gacd8ee8b3cdc5253a300a3b786ff762b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895619ab5b7eb5cd3e4a27a7f2dffc67" id="r_ga895619ab5b7eb5cd3e4a27a7f2dffc67"><td class="memItemLeft" align="right" valign="top"><a id="ga895619ab5b7eb5cd3e4a27a7f2dffc67" name="ga895619ab5b7eb5cd3e4a27a7f2dffc67"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_TYPE_NAME_HAAR</b>&#160;&#160;&#160;&quot;opencv-haar-classifier&quot;</td></tr>
<tr class="separator:ga895619ab5b7eb5cd3e4a27a7f2dffc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7f2403319efc32466187eaedec6ce7" id="r_ga1d7f2403319efc32466187eaedec6ce7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__objdetect__c.html#ga1d7f2403319efc32466187eaedec6ce7">CV_IS_HAAR_CLASSIFIER</a>(haar)</td></tr>
<tr class="separator:ga1d7f2403319efc32466187eaedec6ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d742542c40513ae056b7eca665bd25" id="r_ga54d742542c40513ae056b7eca665bd25"><td class="memItemLeft" align="right" valign="top"><a id="ga54d742542c40513ae056b7eca665bd25" name="ga54d742542c40513ae056b7eca665bd25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_FEATURE_MAX</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga54d742542c40513ae056b7eca665bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb074ea5afa72bbb137bc77ce921e3a7" id="r_gabb074ea5afa72bbb137bc77ce921e3a7"><td class="memItemLeft" align="right" valign="top"><a id="gabb074ea5afa72bbb137bc77ce921e3a7" name="gabb074ea5afa72bbb137bc77ce921e3a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_DO_CANNY_PRUNING</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gabb074ea5afa72bbb137bc77ce921e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812f46d031349fa2ee78a5e7240f5016" id="r_ga812f46d031349fa2ee78a5e7240f5016"><td class="memItemLeft" align="right" valign="top"><a id="ga812f46d031349fa2ee78a5e7240f5016" name="ga812f46d031349fa2ee78a5e7240f5016"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_SCALE_IMAGE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga812f46d031349fa2ee78a5e7240f5016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1734494723ac7a1c009e3d820804099" id="r_gab1734494723ac7a1c009e3d820804099"><td class="memItemLeft" align="right" valign="top"><a id="gab1734494723ac7a1c009e3d820804099" name="gab1734494723ac7a1c009e3d820804099"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_FIND_BIGGEST_OBJECT</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gab1734494723ac7a1c009e3d820804099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4c504e5da7edeed3642ce05e0db15d" id="r_gaaf4c504e5da7edeed3642ce05e0db15d"><td class="memItemLeft" align="right" valign="top"><a id="gaaf4c504e5da7edeed3642ce05e0db15d" name="gaaf4c504e5da7edeed3642ce05e0db15d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_DO_ROUGH_SEARCH</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gaaf4c504e5da7edeed3642ce05e0db15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf3352c3cbfc7c99b4c7a3705242750cf" id="r_gaf3352c3cbfc7c99b4c7a3705242750cf"><td class="memItemLeft" align="right" valign="top"><a id="gaf3352c3cbfc7c99b4c7a3705242750cf" name="gaf3352c3cbfc7c99b4c7a3705242750cf"></a>
typedef struct <a class="el" href="struct_cv_haar_feature.html">CvHaarFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarFeature</b></td></tr>
<tr class="separator:gaf3352c3cbfc7c99b4c7a3705242750cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5855ace290e6b74f48b62adc2f35683" id="r_gac5855ace290e6b74f48b62adc2f35683"><td class="memItemLeft" align="right" valign="top"><a id="gac5855ace290e6b74f48b62adc2f35683" name="gac5855ace290e6b74f48b62adc2f35683"></a>
typedef struct <a class="el" href="struct_cv_haar_classifier.html">CvHaarClassifier</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarClassifier</b></td></tr>
<tr class="separator:gac5855ace290e6b74f48b62adc2f35683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c1b164aff56ea63ea58c81e39af4c4" id="r_gae1c1b164aff56ea63ea58c81e39af4c4"><td class="memItemLeft" align="right" valign="top"><a id="gae1c1b164aff56ea63ea58c81e39af4c4" name="gae1c1b164aff56ea63ea58c81e39af4c4"></a>
typedef struct <a class="el" href="struct_cv_haar_stage_classifier.html">CvHaarStageClassifier</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarStageClassifier</b></td></tr>
<tr class="separator:gae1c1b164aff56ea63ea58c81e39af4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cff51069a20252ece5d11554c178be" id="r_gaa2cff51069a20252ece5d11554c178be"><td class="memItemLeft" align="right" valign="top"><a id="gaa2cff51069a20252ece5d11554c178be" name="gaa2cff51069a20252ece5d11554c178be"></a>
typedef struct CvHidHaarClassifierCascade&#160;</td><td class="memItemRight" valign="bottom"><b>CvHidHaarClassifierCascade</b></td></tr>
<tr class="separator:gaa2cff51069a20252ece5d11554c178be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71f158abd69d9859e94b3318f2ae396d" id="r_ga71f158abd69d9859e94b3318f2ae396d"><td class="memItemLeft" align="right" valign="top"><a id="ga71f158abd69d9859e94b3318f2ae396d" name="ga71f158abd69d9859e94b3318f2ae396d"></a>
typedef struct <a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarClassifierCascade</b></td></tr>
<tr class="separator:ga71f158abd69d9859e94b3318f2ae396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3998382e811754880401a24711cd1df" id="r_gab3998382e811754880401a24711cd1df"><td class="memItemLeft" align="right" valign="top"><a id="gab3998382e811754880401a24711cd1df" name="gab3998382e811754880401a24711cd1df"></a>
typedef struct <a class="el" href="struct_cv_avg_comp.html">CvAvgComp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvAvgComp</b></td></tr>
<tr class="separator:gab3998382e811754880401a24711cd1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabece53e393ac6203569b3b3298050d2b" id="r_gabece53e393ac6203569b3b3298050d2b"><td class="memItemLeft" align="right" valign="top"><a id="gabece53e393ac6203569b3b3298050d2b" name="gabece53e393ac6203569b3b3298050d2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CVAPI</b> (<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> *) cvLoadHaarClassifierCascade(const char *directory</td></tr>
<tr class="separator:gabece53e393ac6203569b3b3298050d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1398da9662b305db874b661bc468161a" id="r_ga1398da9662b305db874b661bc468161a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__objdetect__c.html#ga1398da9662b305db874b661bc468161a">CVAPI</a> (void) cvReleaseHaarClassifierCascade(<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> **cascade)</td></tr>
<tr class="memdesc:ga1398da9662b305db874b661bc468161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates an image header.  <br /></td></tr>
<tr class="separator:ga1398da9662b305db874b661bc468161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df70d3fa96db26bfbfd1aeb64183064" id="r_ga6df70d3fa96db26bfbfd1aeb64183064"><td class="memItemLeft" align="right" valign="top"><a id="ga6df70d3fa96db26bfbfd1aeb64183064" name="ga6df70d3fa96db26bfbfd1aeb64183064"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CVAPI</b> (<a class="el" href="struct_cv_seq.html">CvSeq</a> *) cvHaarDetectObjects(const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *image</td></tr>
<tr class="separator:ga6df70d3fa96db26bfbfd1aeb64183064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6c5085461f40a6df1588c01a9c1f96" id="r_ga6c6c5085461f40a6df1588c01a9c1f96"><td class="memItemLeft" align="right" valign="top"><a id="ga6c6c5085461f40a6df1588c01a9c1f96" name="ga6c6c5085461f40a6df1588c01a9c1f96"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (1.1)</td></tr>
<tr class="separator:ga6c6c5085461f40a6df1588c01a9c1f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9d8dd9fa72e86f5ca60daefa3e28c0" id="r_gadc9d8dd9fa72e86f5ca60daefa3e28c0"><td class="memItemLeft" align="right" valign="top"><a id="gadc9d8dd9fa72e86f5ca60daefa3e28c0" name="gadc9d8dd9fa72e86f5ca60daefa3e28c0"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor int min_neighbors&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (3)</td></tr>
<tr class="separator:gadc9d8dd9fa72e86f5ca60daefa3e28c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712cc81422da123251ea9898d506c10c" id="r_ga712cc81422da123251ea9898d506c10c"><td class="memItemLeft" align="right" valign="top"><a id="ga712cc81422da123251ea9898d506c10c" name="ga712cc81422da123251ea9898d506c10c"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor int min_neighbors int flags&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (0)</td></tr>
<tr class="separator:ga712cc81422da123251ea9898d506c10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa815a5bc16d34403bca712cf83271b" id="r_gaaaa815a5bc16d34403bca712cf83271b"><td class="memItemLeft" align="right" valign="top"><a id="gaaaa815a5bc16d34403bca712cf83271b" name="gaaaa815a5bc16d34403bca712cf83271b"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor int min_neighbors int flags <a class="el" href="struct_cv_size.html">CvSize</a> min_size&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (<a class="el" href="group__core__c.html#gad25ce7ac18665d5c9b062283ff0204ed">cvSize</a>(0, 0))</td></tr>
<tr class="separator:gaaaa815a5bc16d34403bca712cf83271b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1586fcd671e0c4cd369a0840595680ef" id="r_ga1586fcd671e0c4cd369a0840595680ef"><td class="memItemLeft" align="right" valign="top"><a id="ga1586fcd671e0c4cd369a0840595680ef" name="ga1586fcd671e0c4cd369a0840595680ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CVAPI</b> (int) cvRunHaarClassifierCascade(const <a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> *cascade</td></tr>
<tr class="separator:ga1586fcd671e0c4cd369a0840595680ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaa572c1e2ae02ed538a1db299f9663a95" id="r_gaa572c1e2ae02ed538a1db299f9663a95"><td class="memItemLeft" align="right" valign="top"><a id="gaa572c1e2ae02ed538a1db299f9663a95" name="gaa572c1e2ae02ed538a1db299f9663a95"></a>
<a class="el" href="struct_cv_size.html">CvSize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>orig_window_size</b></td></tr>
<tr class="separator:gaa572c1e2ae02ed538a1db299f9663a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88f88d4666ea59e5132cedd33f75016" id="r_gac88f88d4666ea59e5132cedd33f75016"><td class="memItemLeft" align="right" valign="top"><a id="gac88f88d4666ea59e5132cedd33f75016" name="gac88f88d4666ea59e5132cedd33f75016"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>cascade</b></td></tr>
<tr class="separator:gac88f88d4666ea59e5132cedd33f75016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5066b4406a7648e61c69bd407d589ddc" id="r_ga5066b4406a7648e61c69bd407d589ddc"><td class="memItemLeft" align="right" valign="top"><a id="ga5066b4406a7648e61c69bd407d589ddc" name="ga5066b4406a7648e61c69bd407d589ddc"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b></td></tr>
<tr class="separator:ga5066b4406a7648e61c69bd407d589ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1302ba7f918063962cf751adcebad452" id="r_ga1302ba7f918063962cf751adcebad452"><td class="memItemLeft" align="right" valign="top"><a id="ga1302ba7f918063962cf751adcebad452" name="ga1302ba7f918063962cf751adcebad452"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b></td></tr>
<tr class="separator:ga1302ba7f918063962cf751adcebad452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9933dc7f409c9e987d15e1527589d3ae" id="r_ga9933dc7f409c9e987d15e1527589d3ae"><td class="memItemLeft" align="right" valign="top"><a id="ga9933dc7f409c9e987d15e1527589d3ae" name="ga9933dc7f409c9e987d15e1527589d3ae"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sqsum</b></td></tr>
<tr class="separator:ga9933dc7f409c9e987d15e1527589d3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea6e73a4c3d228a0eaa6157bed0c54d" id="r_gacea6e73a4c3d228a0eaa6157bed0c54d"><td class="memItemLeft" align="right" valign="top"><a id="gacea6e73a4c3d228a0eaa6157bed0c54d" name="gacea6e73a4c3d228a0eaa6157bed0c54d"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>tilted_sum</b></td></tr>
<tr class="separator:gacea6e73a4c3d228a0eaa6157bed0c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f622eb9b9e06b30862ca90cdf2c078b" id="r_ga1f622eb9b9e06b30862ca90cdf2c078b"><td class="memItemLeft" align="right" valign="top"><a id="ga1f622eb9b9e06b30862ca90cdf2c078b" name="ga1f622eb9b9e06b30862ca90cdf2c078b"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b></td></tr>
<tr class="separator:ga1f622eb9b9e06b30862ca90cdf2c078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c6090aa56793ec8ef2457bc6d45b45" id="r_ga69c6090aa56793ec8ef2457bc6d45b45"><td class="memItemLeft" align="right" valign="top"><a id="ga69c6090aa56793ec8ef2457bc6d45b45" name="ga69c6090aa56793ec8ef2457bc6d45b45"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pt</b></td></tr>
<tr class="separator:ga69c6090aa56793ec8ef2457bc6d45b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1d7f2403319efc32466187eaedec6ce7" name="ga1d7f2403319efc32466187eaedec6ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d7f2403319efc32466187eaedec6ce7">&#9670;&#160;</a></span>CV_IS_HAAR_CLASSIFIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_IS_HAAR_CLASSIFIER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">haar</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((haar) != NULL &amp;&amp;                                                                   \</div>
<div class="line">    (((<span class="keyword">const</span> <a class="code hl_struct" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a>*)(haar))-&gt;flags &amp; CV_MAGIC_MASK)==CV_HAAR_MAGIC_VAL)</div>
<div class="ttc" id="astruct_cv_haar_classifier_cascade_html"><div class="ttname"><a href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a></div><div class="ttdef"><b>Definition</b> objdetect_c.h:107</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1398da9662b305db874b661bc468161a" name="ga1398da9662b305db874b661bc468161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1398da9662b305db874b661bc468161a">&#9670;&#160;</a></span>CVAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates an image header. </p>
<p>Saves an object to a file.</p>
<p>Releases an object.</p>
<p>Unregisters the type.</p>
<p>Registers a new type.</p>
<p>Writes a file node to another file storage.</p>
<p>Reads multiple numbers.</p>
<p>Initializes file node sequence reader.</p>
<p>Initializes the file node sequence reader.</p>
<p>Writes multiple numbers.</p>
<p>Starts the next stream.</p>
<p>Writes an object to file storage.</p>
<p>Writes a comment.</p>
<p>Writes a text string.</p>
<p>Writes a floating-point value.</p>
<p>Writes an integer value.</p>
<p>Finishes writing to a file node collection.</p>
<p>Starts writing a new structure.</p>
<p>Releases file storage.</p>
<p>Makes OpenCV use IPL functions for allocating IplImage and IplROI structures.</p>
<p>Calculates the cross product of two 3D vectors.</p>
<p>Fills an array with random numbers and updates the RNG state.</p>
<p>Converts one array to another with optional linear transformation.</p>
<p>Clears the array.</p>
<p>Sets every element of an array to a given value.</p>
<p>Copies one array to another.</p>
<p>Retrieves low-level information about the array.</p>
<p>Assigns user data to the array header.</p>
<p>Releases array data.</p>
<p>Allocates array data.</p>
<p>Change a specific array element.</p>
<p>Change the particular array element.</p>
<p>Deallocates sparse array.</p>
<p>Deallocates a matrix.</p>
<p>Resets the image ROI to include the entire image and releases the ROI structure.</p>
<p>Sets an image Region Of Interest (ROI) for a given rectangle.</p>
<p>Sets the channel of interest in an IplImage.</p>
<p>Deallocates the image header and the image data.</p>
<p><code>free</code> wrapper. Here and further all the memory releasing functions (that all call cvFree) take double pointer in order to to clear pointer to the data after releasing it. Passing pointer to NULL pointer is Ok: nothing happens in this case</p>
<p>This call is an analogue of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(image )</div>
<div class="line">{</div>
<div class="line">    iplDeallocate(*image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI);</div>
<div class="line">    *image = 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> but it does not use IPL functions by default (see the CV_TURN_ON_IPL_COMPATIBILITY macro). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>This call is a shortened form of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*image )</div>
<div class="line">{</div>
<div class="line">    cvReleaseData(*image);</div>
<div class="line">    cvReleaseImageHeader(image);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>If the ROI is set to NULL and the coi is <em>not</em> 0, the ROI is allocated. Most OpenCV functions do not* support the COI setting, so to process an individual image/matrix channel one may copy (via cvCopy or cvSplit) the channel to a separate image/matrix, process it and then copy the result back (via cvCopy or cvMerge) if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">coi</td><td>The channel of interest. 0 - all channels are selected, 1 - first channel is selected, etc. Note that the channel indices become 1-based.</td></tr>
  </table>
  </dd>
</dl>
<p>If the original image ROI was NULL and the rect is not the whole image, the ROI structure is allocated.</p>
<p>Most OpenCV functions support the use of ROI and treat the image rectangle as a separate image. For example, all of the pixel coordinates are counted from the top-left (or bottom-left) corner of the ROI, not the original image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">rect</td><td>The ROI rectangle</td></tr>
  </table>
  </dd>
</dl>
<p>This produces a similar result to the following, but in addition it releases the ROI structure. : </p><div class="fragment"><div class="line">cvSetImageROI(image, <a class="code hl_function" href="group__core__c.html#gafaffdb9052823163862a88209f379921">cvRect</a>(0, 0, image-&gt;width, image-&gt;height ));</div>
<div class="line">cvSetImageCOI(image, 0);</div>
<div class="ttc" id="agroup__core__c_html_gafaffdb9052823163862a88209f379921"><div class="ttname"><a href="group__core__c.html#gafaffdb9052823163862a88209f379921">cvRect</a></div><div class="ttdeci">CV_INLINE CvRect cvRect(int x, int y, int width, int height)</div><div class="ttdef"><b>Definition</b> types_c.h:796</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>The function decrements the matrix data reference counter and deallocates matrix header. If the data reference counter is 0, it also deallocates the data. : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*mat )</div>
<div class="line">    <a class="code hl_function" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85">cvDecRefData</a>(*mat);</div>
<div class="line">cvFree((<span class="keywordtype">void</span>**)mat);</div>
<div class="ttc" id="agroup__core__c_html_ga67c50b750b763270b8330a18b3172c85"><div class="ttname"><a href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85">cvDecRefData</a></div><div class="ttdeci">CV_INLINE void cvDecRefData(CvArr *arr)</div><div class="ttdoc">Decrements an array data reference counter.</div><div class="ttdef"><b>Definition</b> core_c.h:298</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the matrix</td></tr>
  </table>
  </dd>
</dl>
<p>low-level scalar &lt;-&gt; raw data conversion functions</p>
<p>The function releases the sparse array and clears the array pointer upon exit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the array</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign the new value to a particular array element. In the case of a sparse array the functions create the node if it does not exist yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx</td><td>Array of the element indices </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign a new value to a specific element of a single-channel array. If the array has multiple channels, a runtime error is raised. Note that the Set*D function can be used safely for both single-channel and multiple-channel arrays, though they are a bit slower.</p>
<p>In the case of a sparse array the functions create the node if it does not yet exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>clears element of ND dense array, in case of sparse arrays it deletes the specified node</p>
<p>Repeats source 2d array several times in both horizontal and vertical direction to fill destination array</p>
<p>The function allocates image, matrix or multi-dimensional dense array data. Note that in the case of matrix types OpenCV allocation functions are used. In the case of IplImage they are used unless CV_TURN_ON_IPL_COMPATIBILITY() has been called before. In the latter case IPL functions are used to allocate the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function releases the array data. In the case of <a class="el" href="struct_cv_mat.html">CvMat</a> or <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> it simply calls <a class="el" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85" title="Decrements an array data reference counter.">cvDecRefData()</a>, that is the function can not deallocate external data. See also the note to cvCreateData . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function assigns user data to the array header. Header should be initialized before using cvCreateMatHeader, cvCreateImageHeader, cvCreateMatNDHeader, cvInitMatHeader, cvInitImageHeader or cvInitMatNDHeader. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>User data </td></tr>
    <tr><td class="paramname">step</td><td>Full row length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function fills output variables with low-level information about the array data. All output</p>
<p>parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, the parameters of ROI are returned.</p>
<p>The following example shows how to get access to array elements. It computes absolute values of the array elements : </p><div class="fragment"><div class="line"><span class="keywordtype">float</span>* data;</div>
<div class="line"><span class="keywordtype">int</span> step;</div>
<div class="line"><a class="code hl_struct" href="struct_cv_size.html">CvSize</a> size;</div>
<div class="line"> </div>
<div class="line">cvGetRawData(array, (uchar**)&amp;data, &amp;step, &amp;size);</div>
<div class="line">step /= <span class="keyword">sizeof</span>(data[0]);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = 0; y &lt; size.height; y++, data += step )</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x = 0; x &lt; size.width; x++ )</div>
<div class="line">        data[x] = (<span class="keywordtype">float</span>)fabs(data[x]);</div>
<div class="ttc" id="astruct_cv_size_html"><div class="ttname"><a href="struct_cv_size.html">CvSize</a></div><div class="ttdef"><b>Definition</b> types_c.h:1008</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>Output pointer to the whole image origin or ROI origin if ROI is set </td></tr>
    <tr><td class="paramname">step</td><td>Output full row length in bytes </td></tr>
    <tr><td class="paramname">roi_size</td><td>Output ROI size</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies selected elements from an input array to an output array:</p>
<p class="formulaDsp">
<picture><source srcset="form_224_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[\texttt{dst} (I)= \texttt{src} (I)  \quad \text{if} \quad \texttt{mask} (I)  \ne 0.\]" src="form_224.png"/></picture>
</p>
<p>If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions, and the same size. The function can also copy sparse arrays (mask is not supported in this case). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source array </td></tr>
    <tr><td class="paramname">dst</td><td>The destination array </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies the scalar value to every selected element of the destination array: </p><p class="formulaDsp">
<picture><source srcset="form_225_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[\texttt{arr} (I)= \texttt{value} \quad \text{if} \quad \texttt{mask} (I)  \ne 0\]" src="form_225.png"/></picture>
</p>
<p> If array arr is of IplImage type, then is ROI used, but COI must not be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">value</td><td>Fill value </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears the array. In the case of dense arrays (<a class="el" href="struct_cv_mat.html">CvMat</a>, <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> or IplImage), cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0). In the case of sparse arrays all the elements are removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to be cleared</td></tr>
  </table>
  </dd>
</dl>
<p>Splits a multi-channel array into the set of single-channel arrays or extracts particular [color] plane</p>
<p>Merges a set of single-channel arrays into the single multi-channel array or inserts one particular [color] plane to the array</p>
<p>Copies several channels from input arrays to certain channels of output arrays</p>
<p>The function has several different purposes, and thus has several different names. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:</p>
<p class="formulaDsp">
<picture><source srcset="form_226_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[\texttt{dst} (I) =  \texttt{scale} \texttt{src} (I) + ( \texttt{shift} _0, \texttt{shift} _1,...)\]" src="form_226.png"/></picture>
</p>
<p>All the channels of multi-channel arrays are processed independently.</p>
<p>The type of conversion is done with rounding and saturation, that is if the result of scaling + conversion can not be represented exactly by a value of the destination array element type, it is set to the nearest representable value on the real axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source array </td></tr>
    <tr><td class="paramname">dst</td><td>Destination array </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor </td></tr>
    <tr><td class="paramname">shift</td><td>Value added to the scaled source array elements</td></tr>
  </table>
  </dd>
</dl>
<p>Performs linear transformation on every source array element, stores absolute value of the result: dst(x,y,c) = abs(scale*src(x,y,c)+shift). destination array must have 8u type. In other cases one may use cvConvertScale + cvAbsDiffS</p>
<p>dst(mask) = src1(mask) + src2(mask)</p>
<p>dst(mask) = src(mask) + value</p>
<p>dst(mask) = src1(mask) - src2(mask)</p>
<p>dst(mask) = value - src(mask)</p>
<p>dst(idx) = src1(idx) * src2(idx) * scale (scaled element-wise multiplication of 2 arrays)</p>
<p>element-wise division/inversion with scaling: dst(idx) = src1(idx) * scale / src2(idx) or dst(idx) = scale / src2(idx) if src1 == 0</p>
<p>dst = src1 * scale + src2</p>
<p>dst = src1 * alpha + src2 * beta + gamma</p>
<p>dst(idx) = src1(idx) &amp; src2(idx)</p>
<p>dst(idx) = src(idx) &amp; value</p>
<p>dst(idx) = src1(idx) | src2(idx)</p>
<p>dst(idx) = src(idx) | value</p>
<p>dst(idx) = src1(idx) ^ src2(idx)</p>
<p>dst(idx) = src(idx) ^ value</p>
<p>dst(idx) = ~src(idx)</p>
<p>dst(idx) = lower(idx) &lt;= src(idx) &lt; upper(idx)</p>
<p>dst(idx) = lower &lt;= src(idx) &lt; upper</p>
<p>The comparison operation support single-channel arrays only. Destination image should be 8uC1 or 8sC1 dst(idx) = src1(idx) <em>cmp_op</em> src2(idx)</p>
<p>dst(idx) = src1(idx) <em>cmp_op</em> value</p>
<p>dst(idx) = min(src1(idx),src2(idx))</p>
<p>dst(idx) = max(src1(idx),src2(idx))</p>
<p>dst(idx) = min(src(idx),value)</p>
<p>dst(idx) = max(src(idx),value)</p>
<p>dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))</p>
<p>dst(x,y,c) = abs(src(x,y,c) - value(c))</p>
<p>Does cartesian-&gt;polar coordinates conversion. Either of output components (magnitude or angle) is optional</p>
<p>Does polar-&gt;cartesian coordinates conversion. Either of output components (magnitude or angle) is optional. If magnitude is missing it is assumed to be all 1's</p>
<p>Does powering: dst(idx) = src(idx)^power</p>
<p>Does exponention: dst(idx) = exp(src(idx)). Overflow is not handled yet. Underflow is handled. Maximal relative error is ~7e-6 for single-precision input</p>
<p>Calculates natural logarithms: dst(idx) = log(abs(src(idx))). Logarithm of 0 gives large negative number(~-700) Maximal relative error is ~3e-7 for single-precision output</p>
<p>The function fills the destination array with uniformly or normally distributed random numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>CvRNG state initialized by cvRNG </td></tr>
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">dist_type</td><td>Distribution type <blockquote class="doxtable">
<p>&zwj;- <b>CV_RAND_UNI</b> uniform distribution</p><ul>
<li><b>CV_RAND_NORMAL</b> normal or Gaussian distribution </li>
</ul>
</blockquote>
</td></tr>
    <tr><td class="paramname">param1</td><td>The first parameter of the distribution. In the case of a uniform distribution it is the inclusive lower boundary of the random numbers range. In the case of a normal distribution it is the mean value of the random numbers. </td></tr>
    <tr><td class="paramname">param2</td><td>The second parameter of the distribution. In the case of a uniform distribution it is the exclusive upper boundary of the random numbers range. In the case of a normal distribution it is the standard deviation of the random numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>randu, randn, RNG::fill.</dd></dl>
<p>Finds all real and complex roots of a polynomial equation</p>
<p>The function calculates the cross product of two 3D vectors: </p><p class="formulaDsp">
<picture><source srcset="form_229_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[\texttt{dst} =  \texttt{src1} \times \texttt{src2}\]" src="form_229.png"/></picture>
</p>
<p> or: </p><p class="formulaDsp">
<picture><source srcset="form_230_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[\begin{array}{l} \texttt{dst} _1 =  \texttt{src1} _2  \texttt{src2} _3 -  \texttt{src1} _3  \texttt{src2} _2 \\ \texttt{dst} _2 =  \texttt{src1} _3  \texttt{src2} _1 -  \texttt{src1} _1  \texttt{src2} _3 \\ \texttt{dst} _3 =  \texttt{src1} _1  \texttt{src2} _2 -  \texttt{src1} _2  \texttt{src2} _1 \end{array}\]" src="form_230.png"/></picture>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>The first source vector </td></tr>
    <tr><td class="paramname">src2</td><td>The second source vector </td></tr>
    <tr><td class="paramname">dst</td><td>The destination vector</td></tr>
  </table>
  </dd>
</dl>
<p>Extended matrix transform: dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T</p>
<p>Transforms each element of source array and stores resultant vectors in destination array</p>
<p>Does perspective transform on every element of input array</p>
<p>Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)</p>
<p>Tranposes matrix. Square matrices can be transposed in-place</p>
<p>Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part</p>
<p>Mirror array data around horizontal (flip=0), vertical (flip=1) or both(flip=-1) axises: cvFlip(src) flips images vertically and sequences horizontally (inplace)</p>
<p>Performs Singular Value Decomposition of a matrix</p>
<p>Performs Singular Value Back Substitution (solves A*X = B): flags must be the same as in cvSVD</p>
<p>Finds eigen values and vectors of a symmetric matrix</p>
<ul>
<li>Finds selected eigen values and vectors of a symmetric matrix *&zwj;/ Makes an identity matrix (mat_ij = i == j)</li>
</ul>
<p>Calculates covariation matrix for a set of vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__c.html#core_c_CovarFlags">flags</a></dd></dl>
<p>Calculates mean and standard deviation of pixel values</p>
<p>Finds global minimum, maximum and their positions</p>
<dl class="section see"><dt>See also</dt><dd>ref core_c_NormFlags "flags"</dd>
<dd>
<a class="el" href="group__core__c.html#core_c_ReduceFlags">flags</a></dd></dl>
<p>Discrete Fourier Transform: complex-&gt;complex, real-&gt;ccs (forward), ccs-&gt;real (inverse) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y)) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Discrete Cosine Transform </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Releases memory storage. All the children of a parent must be released before the parent. A child storage returns all the blocks to parent when it is released</p>
<p>Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos) to reuse memory allocated for the storage - cvClearSeq,cvClearSet ... do not free any memory. A child storage returns all the blocks to the parent when it is cleared</p>
<p>Remember a storage "free memory" position</p>
<p>Restore a storage "free memory" position</p>
<p>Changes default size (granularity) of sequence blocks. The default size is ~1Kbyte</p>
<p>Removes the last element from sequence and optionally saves it</p>
<p>Removes the first element from sequence and optioanally saves it</p>
<p>Adds several new elements to the end of sequence</p>
<p>Removes several elements from the end of sequence and optionally saves them</p>
<p>Removes specified sequence element</p>
<p>Removes all the elements from the sequence. The freed memory can be reused later only by the same sequence unless cvClearMemStorage or cvRestoreMemStoragePos is called</p>
<p>Initializes sequence writer. The new elements will be added to the end of sequence</p>
<p>Combination of cvCreateSeq and cvStartAppendToSeq</p>
<p>Updates sequence header. May be useful to get access to some of previously written elements via cvGetSeqElem or sequence reader</p>
<p>Initializes sequence reader. The sequence can be read in forward or backward direction</p>
<p>Changes sequence reader position. It may seek to an absolute or to relative to the current position</p>
<p>Removes sequence slice</p>
<p>Inserts a sequence or array into another sequence</p>
<p>Sorts sequence in-place given element comparison function</p>
<p>Reverses order of sequence elements in-place</p>
<p>Removes element from the set by its index <br  />
</p>
<p>Removes all the elements from the set</p>
<p>Remove edge connecting two vertices</p>
<p>Remove all vertices and edges from the graph</p>
<p>Releases graph scanner.</p>
<p>Does look-up transformation. Elements of the source array (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table</p>
<p>Inserts sequence into tree with specified "parent" sequence. If parent is equal to frame (e.g. the most external contour), then added contour will have null pointer to parent.</p>
<p>Removes contour from tree (together with the contour children).</p>
<p>Normally, the function is not called directly. Instead, a simple macro CV_TURN_ON_IPL_COMPATIBILITY() is used that calls cvSetIPLAllocators and passes there pointers to IPL allocation functions. : </p><div class="fragment"><div class="line">...</div>
<div class="line">CV_TURN_ON_IPL_COMPATIBILITY()</div>
<div class="line">...</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_header</td><td>pointer to a function, creating IPL image header. </td></tr>
    <tr><td class="paramname">allocate_data</td><td>pointer to a function, allocating IPL image data. </td></tr>
    <tr><td class="paramname">deallocate</td><td>pointer to a function, deallocating IPL image. </td></tr>
    <tr><td class="paramname">create_roi</td><td>pointer to a function, creating IPL image ROI (i.e. Region of Interest). </td></tr>
    <tr><td class="paramname">clone_image</td><td>pointer to a function, cloning an IPL image.</td></tr>
  </table>
  </dd>
</dl>
<p>The function closes the file associated with the storage and releases all the temporary structures. It must be called after all I/O operations with the storage are finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Double pointer to the released file storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function starts writing a compound structure (collection) that can be a sequence or a map. After all the structure fields, which can be scalars or structures, are written, cvEndWriteStruct should be called. The function can be used to group some objects or to implement the write function for a some user object (see <a class="el" href="struct_cv_type_info.html" title="Type information.">CvTypeInfo</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written structure. The structure can be accessed by this name when the storage is read. </td></tr>
    <tr><td class="paramname">struct_flags</td><td>A combination one of the following values:<ul>
<li><b>CV_NODE_SEQ</b> the written structure is a sequence (see discussion of CvFileStorage ), that is, its elements do not have a name.</li>
<li><b>CV_NODE_MAP</b> the written structure is a map (see discussion of CvFileStorage ), that is, all its elements have names. One and only one of the two above flags must be specified</li>
<li><b>CV_NODE_FLOW</b> the optional flag that makes sense only for YAML streams. It means that the structure is written as a flow (not as a block), which is more compact. It is recommended to use this flag for structures or arrays whose elements are all scalars. </li>
</ul>
</td></tr>
    <tr><td class="paramname">type_name</td><td>Optional parameter - the object type name. In case of XML it is written as a type_id attribute of the structure opening tag. In the case of YAML it is written after a colon following the structure name (see the example in CvFileStorage description). Mainly it is used with user objects. When the storage is read, the encoded type name is used to determine the object type (see <a class="el" href="struct_cv_type_info.html" title="Type information.">CvTypeInfo</a> and cvFindType ). </td></tr>
    <tr><td class="paramname">attributes</td><td>This parameter is not used in the current implementation</td></tr>
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvStartWriteStruct.</dd></dl>
<p>The function writes a single integer value (with or without a name) to the file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a single floating-point value (with or without a name) to file storage. Special values are encoded as follows: NaN (Not A Number) as .NaN, infinity as +.Inf or -.Inf.</p>
<p>The following example shows how to use the low-level writing functions to store custom structures, such as termination criteria, without registering a new type. : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> write_termcriteria( <a class="code hl_typedef" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs, <span class="keyword">const</span> <span class="keywordtype">char</span>* struct_name,</div>
<div class="line">                         <a class="code hl_struct" href="struct_cv_term_criteria.html">CvTermCriteria</a>* termcrit )</div>
<div class="line">{</div>
<div class="line">    cvStartWriteStruct( fs, struct_name, CV_NODE_MAP, NULL, <a class="code hl_function" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0));</div>
<div class="line">    cvWriteComment( fs, <span class="stringliteral">&quot;termination criteria&quot;</span>, 1 ); <span class="comment">// just a description</span></div>
<div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code hl_variable" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_ITER )</div>
<div class="line">        cvWriteInteger( fs, <span class="stringliteral">&quot;max_iterations&quot;</span>, termcrit-&gt;max_iter );</div>
<div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code hl_variable" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_EPS )</div>
<div class="line">        cvWriteReal( fs, <span class="stringliteral">&quot;accuracy&quot;</span>, termcrit-&gt;epsilon );</div>
<div class="line">    cvEndWriteStruct( fs );</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__c_html_ga678df8d29bbf1c3a7555dd82fd3800bd"><div class="ttname"><a href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a></div><div class="ttdeci">CV_INLINE CvAttrList cvAttrList(const char **attr CV_DEFAULT(NULL), CvAttrList *next CV_DEFAULT(NULL))</div><div class="ttdef"><b>Definition</b> types_c.h:1717</div></div>
<div class="ttc" id="agroup__core__c_html_ga84556d1bb6f1b8b02c04c60246747a7e"><div class="ttname"><a href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a></div><div class="ttdeci">struct CvFileStorage CvFileStorage</div><div class="ttdoc">&quot;black box&quot; representation of the file storage associated with a file on disk.</div><div class="ttdef"><b>Definition</b> persistence.hpp:90</div></div>
<div class="ttc" id="astruct_cv_term_criteria_html"><div class="ttname"><a href="struct_cv_term_criteria.html">CvTermCriteria</a></div><div class="ttdef"><b>Definition</b> types_c.h:836</div></div>
<div class="ttc" id="astruct_cv_term_criteria_html_a78bcb789341fdbd785b794b92555d6e0"><div class="ttname"><a href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">CvTermCriteria::type</a></div><div class="ttdeci">int type</div><div class="ttdef"><b>Definition</b> types_c.h:837</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a text string to file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written string . Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">str</td><td>The written text string </td></tr>
    <tr><td class="paramname">quote</td><td>If non-zero, the written string is put in quotes, regardless of whether they are required. Otherwise, if the flag is zero, quotes are used only when they are required (e.g. when the string starts with a digit or contains spaces).</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a comment into file storage. The comments are skipped when the storage is read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">comment</td><td>The written comment, single-line or multi-line </td></tr>
    <tr><td class="paramname">eol_comment</td><td>If non-zero, the function tries to put the comment at the end of current line. If the flag is zero, if the comment is multi-line, or if it does not fit at the end of the current line, the comment starts a new line.</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an object to file storage. First, the appropriate type info is found using cvTypeOf. Then, the write method associated with the type info is called.</p>
<p>Attributes are used to customize the writing procedure. The standard types support the following attributes (all the dt attributes have the same format as in cvWriteRawData):</p>
<ol type="1">
<li><a class="el" href="struct_cv_seq.html">CvSeq</a><ul>
<li><b>header_dt</b> description of user fields of the sequence header that follow <a class="el" href="struct_cv_seq.html">CvSeq</a>, or <a class="el" href="struct_cv_chain.html">CvChain</a> (if the sequence is a Freeman chain) or <a class="el" href="struct_cv_contour.html">CvContour</a> (if the sequence is a contour or point sequence)</li>
<li><b>dt</b> description of the sequence elements.</li>
<li><b>recursive</b> if the attribute is present and is not equal to "0" or "false", the whole tree of sequences (contours) is stored.</li>
</ul>
</li>
<li><a class="el" href="struct_cv_graph.html">CvGraph</a><ul>
<li><b>header_dt</b> description of user fields of the graph header that follows <a class="el" href="struct_cv_graph.html">CvGraph</a>;</li>
<li><b>vertex_dt</b> description of user fields of graph vertices</li>
<li><b>edge_dt</b> description of user fields of graph edges (note that the edge weight is always written, so there is no need to specify it explicitly)</li>
</ul>
</li>
</ol>
<p>Below is the code that creates the YAML file shown in the CvFileStorage description: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cxcore.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="struct_cv_mat.html">CvMat</a>* mat = cvCreateMat( 3, 3, CV_32F );</div>
<div class="line">    <a class="code hl_typedef" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs = cvOpenFileStorage( <span class="stringliteral">&quot;example.yml&quot;</span>, 0, CV_STORAGE_WRITE );</div>
<div class="line"> </div>
<div class="line">    cvSetIdentity( mat );</div>
<div class="line">    cvWrite( fs, <span class="stringliteral">&quot;A&quot;</span>, mat, <a class="code hl_function" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0) );</div>
<div class="line"> </div>
<div class="line">    cvReleaseFileStorage( &amp;fs );</div>
<div class="line">    cvReleaseMat( &amp;mat );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astruct_cv_mat_html"><div class="ttname"><a href="struct_cv_mat.html">CvMat</a></div><div class="ttdef"><b>Definition</b> types_c.h:424</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written object. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the object </td></tr>
    <tr><td class="paramname">attributes</td><td>The attributes of the object. They are specific for each particular type (see the discussion below).</td></tr>
  </table>
  </dd>
</dl>
<p>The function finishes the currently written stream and starts the next stream. In the case of XML the file with multiple streams looks like this: </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div>
<div class="line"><span class="comment">&lt;!-- stream #1 data --&gt;</span></div>
<div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div>
<div class="line"><span class="comment">&lt;!-- stream #2 data --&gt;</span></div>
<div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div>
<div class="line">...</div>
</div><!-- fragment --><p> The YAML file will look like this: </p><div class="fragment"><div class="line">%YAML:1.0</div>
<div class="line"># stream #1 data</div>
<div class="line">...</div>
<div class="line">---</div>
<div class="line"># stream #2 data</div>
</div><!-- fragment --><p> This is useful for concatenating files or for resuming the writing process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an array, whose elements consist of single or multiple numbers. The function call can be replaced with a loop containing a few cvWriteInt and cvWriteReal calls, but a single call is more efficient. Note that because none of the elements have a name, they should be written to a sequence rather than a map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the written array </td></tr>
    <tr><td class="paramname">len</td><td>Number of the array elements to write </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element, see <a class="el" href="group__core__xml.html#format_spec">format specification</a></td></tr>
  </table>
  </dd>
</dl>
<p>The function initializes the sequence reader to read data from a file node. The initialized reader can be then passed to cvReadRawDataSlice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">reader</td><td>Pointer to the sequence reader</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads one or more elements from the file node, representing a sequence, to a user-specified array. The total number of read sequence elements is a product of total and the number of components in each array element. For example, if dt=2if, the function will read total*3 sequence elements. As with any sequence, some parts of the file node sequence can be skipped or read repeatedly by repositioning the reader using cvSetSeqReaderPos. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">reader</td><td>The sequence reader. Initialize it with cvStartReadRawData . </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to read </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads elements from a file node that represents a sequence of scalars. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a copy of a file node to file storage. Possible applications of the function are merging several file storages into one and conversion between XML and YAML formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Destination file storage </td></tr>
    <tr><td class="paramname">new_node_name</td><td>New name of the file node in the destination file storage. To keep the existing name, use cvcvGetFileNodeName </td></tr>
    <tr><td class="paramname">node</td><td>The written node </td></tr>
    <tr><td class="paramname">embed</td><td>If the written node is a collection and this parameter is not zero, no extra level of hierarchy is created. Instead, all the elements of node are written into the currently written structure. Of course, map elements can only be embedded into another map, and sequence elements can only be embedded into another sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>The function registers a new type, which is described by info . The function creates a copy of the structure, so the user should delete it after calling the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Type info structure</td></tr>
  </table>
  </dd>
</dl>
<p>The function unregisters a type with a specified name. If the name is unknown, it is possible to locate the type info by an instance of the type using cvTypeOf or by iterating the type list, starting from cvFirstType, and then calling cvUnregisterType(info-&gt;typeName). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>Name of an unregistered type</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds the type of a given object and calls release with the double pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_ptr</td><td>Double pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<p>The function saves an object to a file. It provides a simple interface to cvWrite . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File name </td></tr>
    <tr><td class="paramname">struct_ptr</td><td>Object to save </td></tr>
    <tr><td class="paramname">name</td><td>Optional object name. If it is NULL, the name will be formed from filename . </td></tr>
    <tr><td class="paramname">comment</td><td>Optional comment to put in the beginning of the file </td></tr>
    <tr><td class="paramname">attributes</td><td>Optional attributes passed to cvWrite</td></tr>
  </table>
  </dd>
</dl>
<p>Sets error status silently</p>
<p>Sets error status and performs some additonal actions (displaying message box, writing message to stderr, terminating application etc.) depending on the current error mode </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
